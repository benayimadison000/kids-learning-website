<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Brick Builder</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Use min-height to ensure it fills the screen */
            margin: 0;
            font-family: 'VT323', monospace;
            overflow-x: hidden; /* Prevent horizontal scroll when scaled */
        }

        /* The Handheld Console Case */
        #console-case {
            background-color: #f1c40f; /* Retro Yellow */
            padding: 30px;
            border-radius: 20px 20px 40px 40px;
            box-shadow: 
                inset -5px -5px 10px rgba(0,0,0,0.2),
                inset 5px 5px 10px rgba(255,255,255,0.4),
                10px 10px 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            /* Default max-width for desktop viewing */
            max-width: 450px; 
            box-sizing: border-box;
        }

        /* --- Responsive Scaling for Small Screens --- */
        
        /* Targetting Narrow Mobile Screens (Portrait) */
        @media screen and (max-width: 500px) {
            #console-case {
                /* Scale the entire console down to fit inside the narrow screen */
                transform: scale(0.85); 
                transform-origin: center top; 
                margin-top: 20px; 
            }
            body {
                /* Start content near the top of the viewport after scaling */
                align-items: flex-start;
                padding-top: 5vh; 
            }
        }

        /* Targetting Landscape Mobile Screens (Short height) */
        @media screen and (max-height: 700px) and (orientation: landscape) {
            #console-case {
                /* Scale smaller to ensure the console height fits into the viewport height */
                transform: scale(0.7); 
                transform-origin: center center;
                margin: 0;
            }
            body {
                 /* Center vertically again for landscape */
                align-items: center; 
                padding: 0;
            }
        }
        /* ------------------------------------------- */

        /* The Screen Bezel */
        #screen-bezel {
            background-color: #7f8c8d;
            padding: 20px 30px;
            border-radius: 10px 10px 30px 10px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
            margin-bottom: 30px;
            position: relative;
        }

        #screen-glass {
            background-color: #9cad87; /* Classic LCD Greenish tint */
            border: 4px solid #34495e;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3);
            position: relative;
        }

        canvas {
            display: block;
        }

        /* UI Overlay on Screen */
        .ui-text {
            position: absolute;
            color: #2c3e50;
            opacity: 0.8;
            pointer-events: none;
        }
        
        #score-display { top: 10px; right: 10px; font-size: 24px; text-align: right; }
        #level-display { top: 35px; right: 10px; font-size: 20px; text-align: right; }
        
        /* New Next Piece Display */
        #next-display { top: 10px; left: 10px; font-size: 20px; text-align: left; }
        #nextCanvas { margin-top: 5px; opacity: 0.8; }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            text-align: center;
            display: none;
            background: rgba(156, 173, 135, 0.9);
            padding: 10px;
            border: 2px solid #2c3e50;
        }

        #start-msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            text-align: center;
            width: 100%;
            animation: blink 1s infinite;
        }

        /* Controls Area */
        #controls-area {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
        }

        /* D-Pad */
        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
        }
        .d-btn {
            position: absolute;
            background: #34495e;
            border: none;
            box-shadow: 0 4px 0 #2c3e50;
            cursor: pointer;
        }
        .d-btn:active { transform: translateY(4px); box-shadow: none; }
        
        .d-up { width: 40px; height: 40px; top: 0; left: 40px; border-radius: 5px 5px 0 0; }
        .d-down { width: 40px; height: 40px; bottom: 0; left: 40px; border-radius: 0 0 5px 5px; }
        .d-left { width: 40px; height: 40px; top: 40px; left: 0; border-radius: 5px 0 0 5px; }
        .d-right { width: 40px; height: 40px; top: 40px; right: 0; border-radius: 0 5px 5px 0; }
        .d-center { width: 40px; height: 40px; top: 40px; left: 40px; background: #34495e; }

        /* Action Buttons */
        .action-area {
            display: flex;
            gap: 20px;
            transform: rotate(-15deg);
        }
        .action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #e74c3c;
            border: none;
            box-shadow: 0 5px 0 #c0392b;
            cursor: pointer;
            font-family: 'VT323';
            font-size: 20px;
            color: rgba(0,0,0,0.3);
        }
        .action-btn:active { transform: translateY(5px); box-shadow: none; }

        @keyframes blink { 50% { opacity: 0; } }
        
        /* Grid effect overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(44, 62, 80, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(44, 62, 80, 0.1) 1px, transparent 1px);
            background-size: 30px 30px; /* Must match BLOCK_SIZE */
            pointer-events: none;
        }

    </style>
</head>
<body>

    <div id="console-case">
        <div id="screen-bezel">
            <div id="screen-glass">
                <canvas id="tetrisCanvas" width="300" height="600"></canvas>
                <div class="grid-overlay"></div>
                
                <!-- Added Next Piece Display -->
                <div class="ui-text" id="next-display">
                    NEXT<br>
                    <canvas id="nextCanvas" width="80" height="80"></canvas>
                </div>

                <div class="ui-text" id="score-display">SCORE<br>000000</div>
                <div class="ui-text" id="level-display">LVL 1</div>
                
                <div id="start-msg">PRESS START</div>
                <div id="game-over">GAME OVER<br><span style="font-size:20px">Press Reset</span></div>
            </div>
            <div style="text-align:center; color:#bdc3c7; font-size:14px; margin-top:5px;">DOT MATRIX WITH STEREO SOUND</div>
        </div>

        <div id="controls-area">
            <div class="d-pad">
                <button class="d-btn d-up" onclick="rotate()"></button>
                <button class="d-btn d-left" onclick="move(-1)"></button>
                <button class="d-btn d-center"></button>
                <button class="d-btn d-right" onclick="move(1)"></button>
                <button class="d-btn d-down" onclick="drop()"></button>
            </div>
            
            <div style="display:flex; gap:10px; margin-bottom: 20px;">
                <div style="text-align:center;">
                    <button class="action-btn" style="width:40px; height:15px; border-radius:10px; background:#95a5a6; box-shadow:0 3px 0 #7f8c8d;" onclick="resetGame()"></button>
                    <div style="font-size:12px; color:#2c3e50; font-weight:bold;">RESET</div>
                </div>
                <div style="text-align:center;">
                    <button class="action-btn" style="width:40px; height:15px; border-radius:10px; background:#95a5a6; box-shadow:0 3px 0 #7f8c8d;" onclick="startGame()"></button>
                    <div style="font-size:12px; color:#2c3e50; font-weight:bold;">START</div>
                </div>
            </div>

            <div class="action-area">
                <div style="text-align:center;">
                    <button class="action-btn" onclick="rotate()">A</button>
                </div>
                <div style="text-align:center; margin-top: 20px;">
                    <button class="action-btn" onclick="dropHard()">B</button>
                </div>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('tetrisCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    
    // --- Constants ---
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30; // Matches CSS grid background
    const COLORS = [
        null,
        '#FF0D72', // T - Purple/Magenta
        '#0DC2FF', // I - Cyan
        '#0DFF72', // S - Green
        '#F538FF', // Z - Pinkish (Gameboy style variation)
        '#FF8E0D', // L - Orange
        '#FFE138', // O - Yellow
        '#3877FF', // J - Blue
    ];

    // --- Audio ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playBeep(freq, type, duration) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
        osc.stop(audioCtx.currentTime + duration);
    }

    function soundMove() { playBeep(200, 'square', 0.1); }
    function soundRotate() { playBeep(300, 'square', 0.1); }
    function soundDrop() { playBeep(100, 'sawtooth', 0.2); }
    function soundClear() { 
        playBeep(400, 'square', 0.1); 
        setTimeout(() => playBeep(600, 'square', 0.2), 100);
    }
    function soundGameOver() {
        playBeep(300, 'sawtooth', 0.3);
        setTimeout(() => playBeep(250, 'sawtooth', 0.3), 250);
        setTimeout(() => playBeep(200, 'sawtooth', 0.6), 500);
    }

    // --- Shapes ---
    const SHAPES = [
        [],
        [[0, 1, 0], [1, 1, 1], [0, 0, 0]], // T
        [[0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0]], // I
        [[0, 3, 3], [3, 3, 0], [0, 0, 0]], // S
        [[4, 4, 0], [0, 4, 4], [0, 0, 0]], // Z
        [[0, 0, 5], [5, 5, 5], [0, 0, 0]], // L
        [[6, 6], [6, 6]], // O
        [[7, 0, 0], [7, 7, 7], [0, 0, 0]]  // J
    ];

    // --- Game State ---
    let board = [];
    let score = 0;
    let level = 1;
    let dropInterval = 1000;
    let lastTime = 0;
    let dropCounter = 0;
    let isPaused = true;
    let isGameOver = false;
    let nextPieceType = null; // Store next piece

    // Current Piece
    const piece = {
        matrix: null,
        pos: {x: 0, y: 0},
        colorIndex: 0
    };

    function resetBoard() {
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    }

    function createPiece(type) {
        // If start of game (nextPieceType is null), gen random next
        if (!nextPieceType) {
            nextPieceType = (Math.random() * 7 | 0) + 1;
        }

        // Current piece becomes what was in "Next"
        const currentType = nextPieceType;
        
        // Generate a new "Next" piece
        nextPieceType = (Math.random() * 7 | 0) + 1;

        piece.matrix = JSON.parse(JSON.stringify(SHAPES[currentType])); // Deep copy
        piece.colorIndex = currentType;
        // Center the piece
        piece.pos.y = 0;
        piece.pos.x = (COLS / 2 | 0) - (piece.matrix[0].length / 2 | 0);
        
        drawNext(); // Update the display

        // Immediate collision check = Game Over
        if (collide(board, piece)) {
            isGameOver = true;
            isPaused = true;
            soundGameOver();
            document.getElementById('game-over').style.display = 'block';
        }
    }

    function drawNext() {
        // Clear next canvas
        nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        
        if (!nextPieceType) return;

        const matrix = SHAPES[nextPieceType];
        const previewBlockSize = 20;
        
        // Calculate center offset
        const width = matrix[0].length * previewBlockSize;
        const height = matrix.length * previewBlockSize;
        const offsetX = (nextCanvas.width - width) / 2;
        const offsetY = (nextCanvas.height - height) / 2;

        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    // Draw block
                    nextCtx.fillStyle = COLORS[value];
                    nextCtx.fillRect(offsetX + x * previewBlockSize, offsetY + y * previewBlockSize, previewBlockSize, previewBlockSize);
                    
                    // Bevel
                    nextCtx.lineWidth = 1;
                    nextCtx.strokeStyle = 'rgba(0,0,0,0.5)';
                    nextCtx.strokeRect(offsetX + x * previewBlockSize, offsetY + y * previewBlockSize, previewBlockSize, previewBlockSize);
                    
                    // Highlight
                    nextCtx.fillStyle = 'rgba(255,255,255,0.4)';
                    nextCtx.fillRect(offsetX + x * previewBlockSize + 1, offsetY + y * previewBlockSize + 1, previewBlockSize - 2, 2);
                }
            });
        });
    }

    function drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    // Draw main block
                    ctx.fillStyle = COLORS[value];
                    ctx.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    
                    // Retro Bevel Effect
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                    ctx.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    
                    // Highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.fillRect((x + offset.x) * BLOCK_SIZE + 2, (y + offset.y) * BLOCK_SIZE + 2, BLOCK_SIZE - 4, 4);
                }
            });
        });
    }

    function draw() {
        // Clear screen (LCD background color)
        ctx.fillStyle = '#9cad87'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw shadow of placed pieces (LCD "inactive" blocks) - optional visual flair
        ctx.fillStyle = 'rgba(44, 62, 80, 0.05)';
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                ctx.fillRect(x*BLOCK_SIZE + 2, y*BLOCK_SIZE + 2, BLOCK_SIZE-4, BLOCK_SIZE-4);
            }
        }

        drawMatrix(board, {x: 0, y: 0});
        if (!isGameOver) {
            drawMatrix(piece.matrix, piece.pos);
        }
    }

    function merge(board, piece) {
        piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    board[y + piece.pos.y][x + piece.pos.x] = value;
                }
            });
        });
    }

    function collide(board, piece) {
        const m = piece.matrix;
        const o = piece.pos;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 &&
                   (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function rotateMatrix(matrix) {
        // Transpose + Reverse rows
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        matrix.forEach(row => row.reverse());
    }

    function rotate() {
        if (isPaused) return;
        const pos = piece.pos.x;
        let offset = 1;
        rotateMatrix(piece.matrix);
        // Wall kick logic (basic)
        while (collide(board, piece)) {
            piece.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > piece.matrix[0].length) {
                rotateMatrix(piece.matrix); // Rotate back
                rotateMatrix(piece.matrix);
                rotateMatrix(piece.matrix);
                piece.pos.x = pos;
                return;
            }
        }
        soundRotate();
    }

    function sweep() {
        let rowCount = 0;
        outer: for (let y = board.length - 1; y > 0; --y) {
            for (let x = 0; x < board[y].length; ++x) {
                if (board[y][x] === 0) {
                    continue outer;
                }
            }
            // Remove row
            const row = board.splice(y, 1)[0].fill(0);
            board.unshift(row);
            ++y;
            rowCount++;
        }
        
        if (rowCount > 0) {
            soundClear();
            // Classic scoring: 40, 100, 300, 1200 * (level + 1)
            const lineScores = [0, 40, 100, 300, 1200];
            score += lineScores[rowCount] * (level);
            
            // Level up every 500 points (simplified)
            level = Math.floor(score / 500) + 1;
            dropInterval = Math.max(100, 1000 - (level * 100)); // Speed up

            updateScore();
        }
    }

    function updateScore() {
        document.getElementById('score-display').innerHTML = `SCORE<br>${score.toString().padStart(6, '0')}`;
        document.getElementById('level-display').innerHTML = `LVL ${level}`;
    }

    function drop() {
        if (isPaused) return;
        piece.pos.y++;
        if (collide(board, piece)) {
            piece.pos.y--;
            merge(board, piece);
            soundDrop();
            sweep();
            createPiece();
        }
        dropCounter = 0;
    }
    
    function dropHard() {
        if (isPaused) return;
        while (!collide(board, piece)) {
            piece.pos.y++;
        }
        piece.pos.y--;
        merge(board, piece);
        soundDrop();
        sweep();
        createPiece();
    }

    function move(dir) {
        if (isPaused) return;
        piece.pos.x += dir;
        if (collide(board, piece)) {
            piece.pos.x -= dir;
        } else {
            soundMove();
        }
    }

    function update(time = 0) {
        if (!isPaused && !isGameOver) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                drop();
            }
            draw();
        }
        requestAnimationFrame(update);
    }

    function startGame() {
        if (isGameOver) resetGame();
        isPaused = false;
        document.getElementById('start-msg').style.display = 'none';
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function resetGame() {
        resetBoard();
        score = 0;
        level = 1;
        dropInterval = 1000;
        isGameOver = false;
        isPaused = true;
        nextPieceType = null; // Reset next piece queue
        document.getElementById('game-over').style.display = 'none';
        document.getElementById('start-msg').style.display = 'block';
        
        // Clear next canvas visually
        nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        
        updateScore();
        createPiece();
        draw();
    }

    // Controls
    document.addEventListener('keydown', event => {
        if (isGameOver) return;
        
        // Prevent default scrolling for arrow keys
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(event.code) > -1) {
            event.preventDefault();
        }

        if (event.keyCode === 37) move(-1); // Left
        else if (event.keyCode === 39) move(1); // Right
        else if (event.keyCode === 40) drop(); // Down
        else if (event.keyCode === 38) rotate(); // Up (Rotate)
        else if (event.keyCode === 32) dropHard(); // Space (Hard Drop)
        else if (event.keyCode === 13) startGame(); // Enter (Start)
    });

    // Initialize
    resetBoard();
    createPiece();
    updateScore();
    draw();
    update();

</script>
</body>
</html>