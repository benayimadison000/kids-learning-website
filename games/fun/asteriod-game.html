<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Asteroid Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #score-board {
            padding: 20px;
            color: #00ffcc;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffcc;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .health-bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid #ff3366;
            border-radius: 10px;
            overflow: hidden;
            background: rgba(50, 0, 20, 0.5);
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #ff3366;
            transition: width 0.2s;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            color: #fff;
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00ffcc;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-align: center;
        }

        p {
            color: #ccc;
            font-size: 18px;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }

        button {
            background: transparent;
            color: #00ffcc;
            border: 2px solid #00ffcc;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
        }

        button:hover {
            background: #00ffcc;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.6);
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            display: none; /* Hidden on desktop by default */
            pointer-events: auto;
            touch-action: none;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .control-zone {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 204, 0.5);
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 0 10px #00ffcc;
        }

        #fire-btn {
            background: rgba(255, 51, 102, 0.3);
            border-color: rgba(255, 51, 102, 0.5);
        }

        #fire-btn:active {
            background: rgba(255, 51, 102, 0.6);
        }

        .fire-icon {
            width: 60px;
            height: 60px;
            background: #ff3366;
            border-radius: 50%;
            box-shadow: 0 0 15px #ff3366;
        }

        .hidden {
            display: none !important;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">
            <div id="score">SCORE: 0</div>
            <div class="health-bar-container">
                <div id="health-fill"></div>
            </div>
        </div>
        
        <!-- Touch controls container -->
        <div id="mobile-controls">
            <div id="joystick-zone" class="control-zone">
                <div id="joystick-knob"></div>
            </div>
            <div id="fire-zone" class="control-zone" style="border: none; background: transparent;">
                <div id="fire-btn" class="control-zone">
                    <div class="fire-icon"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Void Defender</h1>
        <p>Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move.<br>
        Press <strong>Space</strong> or <strong>Click</strong> to shoot.<br>
        On mobile, use the left joystick to move and right button to fire.</p>
        <button id="start-btn">Initialize System</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #ff3366; text-shadow: 0 0 20px #ff3366;">CRITICAL FAILURE</h1>
        <p>Your ship has been destroyed.</p>
        <p id="final-score" style="font-size: 24px; color: #fff;">Score: 0</p>
        <button id="restart-btn">Reboot System</button>
    </div>

<script>
/**
 * Game Configuration & State
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const healthFill = document.getElementById('health-fill');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const finalScoreEl = document.getElementById('final-score');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');

// Mobile Controls
const joystickZone = document.getElementById('joystick-zone');
const joystickKnob = document.getElementById('joystick-knob');
const fireBtn = document.getElementById('fire-btn');

let width, height;
let animationId;
let lastTime = 0;
let score = 0;
let gameActive = false;
let frameCount = 0;

// Ship
const ship = {
    x: 0,
    y: 0,
    radius: 20,
    angle: -Math.PI / 2, // Pointing up
    velocity: { x: 0, y: 0 },
    maxSpeed: 6,
    friction: 0.96, // slippery space
    acceleration: 0.5,
    rotationSpeed: 0.1,
    color: '#00ffcc',
    health: 100,
    maxHealth: 100,
    invulnerable: false,
    invulnerableTime: 0
};

// Input State
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    w: false, s: false, a: false, d: false,
    " ": false
};

const touchInput = {
    active: false,
    dx: 0,
    dy: 0,
    firing: false
};

// Game Objects Arrays
let bullets = [];
let asteroids = [];
let particles = [];
let stars = [];

/**
 * Setup & Resize
 */
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    // Generate background stars
    stars = [];
    for(let i=0; i<100; i++) {
        stars.push({
            x: Math.random() * width,
            y: Math.random() * height,
            size: Math.random() * 2,
            brightness: Math.random()
        });
    }

    // Reposition ship if game not running
    if (!gameActive) {
        ship.x = width / 2;
        ship.y = height / 2;
    }
}
window.addEventListener('resize', resize);
resize();

/**
 * Input Handling
 */
window.addEventListener('keydown', (e) => {
    if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
    if(e.key === " " && gameActive) fireBullet();
});

window.addEventListener('keyup', (e) => {
    if(keys.hasOwnProperty(e.key)) keys[e.key] = false;
});

// Mouse to shoot (Desktop)
window.addEventListener('mousedown', (e) => {
    // Only fire if not clicking a button
    if (e.target.tagName !== 'BUTTON' && gameActive && !touchInput.active) {
        fireBullet();
    }
});

// Joystick Logic
let joystickCenter = { x: 0, y: 0 };
let joystickTouchId = null;

joystickZone.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    joystickTouchId = touch.identifier;
    
    const rect = joystickZone.getBoundingClientRect();
    joystickCenter = { 
        x: rect.left + rect.width / 2, 
        y: rect.top + rect.height / 2 
    };
    
    updateJoystick(touch.clientX, touch.clientY);
}, { passive: false });

joystickZone.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === joystickTouchId) {
            updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
            break;
        }
    }
}, { passive: false });

joystickZone.addEventListener('touchend', (e) => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === joystickTouchId) {
            joystickTouchId = null;
            resetJoystick();
            break;
        }
    }
}, { passive: false });

function updateJoystick(touchX, touchY) {
    const maxDist = 35;
    let dx = touchX - joystickCenter.x;
    let dy = touchY - joystickCenter.y;
    
    const distance = Math.sqrt(dx*dx + dy*dy);
    
    // Normalize input
    if (distance > maxDist) {
        const ratio = maxDist / distance;
        dx *= ratio;
        dy *= ratio;
    }
    
    // Move visual knob
    joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;
    
    // Update game input (-1 to 1)
    touchInput.active = true;
    touchInput.dx = dx / maxDist;
    touchInput.dy = dy / maxDist;
}

function resetJoystick() {
    joystickKnob.style.transform = `translate(0px, 0px)`;
    touchInput.active = false;
    touchInput.dx = 0;
    touchInput.dy = 0;
}

// Fire Button Logic
fireBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(gameActive) fireBullet();
    fireBtn.style.transform = 'scale(0.9)';
}, { passive: false });

fireBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    fireBtn.style.transform = 'scale(1)';
}, { passive: false });

/**
 * Game Logic
 */

function startGame() {
    score = 0;
    ship.health = 100;
    ship.x = width / 2;
    ship.y = height / 2;
    ship.velocity = {x: 0, y: 0};
    ship.invulnerable = true;
    ship.invulnerableTime = 120; // 2 seconds at 60fps
    
    bullets = [];
    asteroids = [];
    particles = [];
    
    scoreEl.innerText = "SCORE: 0";
    updateHealthUI();
    
    gameActive = true;
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function gameOver() {
    gameActive = false;
    finalScoreEl.innerText = "Score: " + score;
    gameOverScreen.classList.remove('hidden');
}

function fireBullet() {
    // Offset bullet start to ship nose
    const noseX = ship.x + Math.cos(ship.angle) * ship.radius;
    const noseY = ship.y + Math.sin(ship.angle) * ship.radius;
    
    bullets.push({
        x: noseX,
        y: noseY,
        dx: Math.cos(ship.angle) * 12 + ship.velocity.x * 0.5,
        dy: Math.sin(ship.angle) * 12 + ship.velocity.y * 0.5,
        life: 60 // frames
    });
}

function createAsteroid(x, y, size) {
    const radius = size === 'large' ? 40 : size === 'medium' ? 20 : 10;
    const speed = size === 'large' ? 2 : size === 'medium' ? 3.5 : 5;
    
    // Procedural jagged shape
    const vertices = [];
    const numVerts = 8 + Math.floor(Math.random() * 5);
    for(let i=0; i<numVerts; i++) {
        const angle = (i / numVerts) * Math.PI * 2;
        // Randomize radius slightly for rocky look
        const r = radius * (0.8 + Math.random() * 0.4); 
        vertices.push({
            x: Math.cos(angle) * r,
            y: Math.sin(angle) * r
        });
    }

    // Velocity towards center generally, but randomized
    let angle;
    if (x === undefined) {
        // Spawn from edge
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -radius : width + radius;
            y = Math.random() * height;
        } else {
            x = Math.random() * width;
            y = Math.random() < 0.5 ? -radius : height + radius;
        }
        angle = Math.atan2(height/2 - y, width/2 - x) + (Math.random() - 0.5);
    } else {
        // Spawn from split
        angle = Math.random() * Math.PI * 2;
    }

    asteroids.push({
        x: x,
        y: y,
        dx: Math.cos(angle) * speed,
        dy: Math.sin(angle) * speed,
        radius: radius,
        size: size,
        rotation: 0,
        rotationSpeed: (Math.random() - 0.5) * 0.1,
        vertices: vertices
    });
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x,
            y: y,
            dx: (Math.random() - 0.5) * 5,
            dy: (Math.random() - 0.5) * 5,
            life: 30 + Math.random() * 20,
            color: color,
            size: Math.random() * 3
        });
    }
}

function updateHealthUI() {
    const pct = Math.max(0, (ship.health / ship.maxHealth) * 100);
    healthFill.style.width = `${pct}%`;
}

function gameLoop(timestamp) {
    if (!gameActive) return;
    
    // Calculate delta time (optional, simplified here to fixed steps mostly)
    
    ctx.clearRect(0, 0, width, height);
    
    // Draw Stars
    ctx.fillStyle = "#fff";
    stars.forEach(star => {
        ctx.globalAlpha = star.brightness;
        ctx.fillRect(star.x, star.y, star.size, star.size);
    });
    ctx.globalAlpha = 1.0;

    // --- UPDATE SHIP ---
    if (touchInput.active) {
        // Joystick control
        ship.velocity.x += touchInput.dx * ship.acceleration;
        ship.velocity.y += touchInput.dy * ship.acceleration;
        
        // Rotate towards movement direction if moving significantly
        if (Math.abs(touchInput.dx) > 0.1 || Math.abs(touchInput.dy) > 0.1) {
            const targetAngle = Math.atan2(touchInput.dy, touchInput.dx);
            // Smooth rotation
            let diff = targetAngle - ship.angle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            ship.angle += diff * 0.2;
        }
    } else {
        // Keyboard control
        if (keys.ArrowUp || keys.w) {
            ship.velocity.x += Math.cos(ship.angle) * ship.acceleration;
            ship.velocity.y += Math.sin(ship.angle) * ship.acceleration;
            
            // Thruster particle
            if (Math.random() > 0.5) {
                particles.push({
                    x: ship.x - Math.cos(ship.angle) * ship.radius,
                    y: ship.y - Math.sin(ship.angle) * ship.radius,
                    dx: -Math.cos(ship.angle) * 3 + (Math.random()-0.5),
                    dy: -Math.sin(ship.angle) * 3 + (Math.random()-0.5),
                    life: 10,
                    color: '#00ffff',
                    size: 2
                });
            }
        }
        if (keys.ArrowLeft || keys.a) ship.angle -= ship.rotationSpeed;
        if (keys.ArrowRight || keys.d) ship.angle += ship.rotationSpeed;
    }

    // Apply friction
    ship.velocity.x *= ship.friction;
    ship.velocity.y *= ship.friction;
    
    // Cap speed
    const speed = Math.sqrt(ship.velocity.x**2 + ship.velocity.y**2);
    if (speed > ship.maxSpeed) {
        ship.velocity.x = (ship.velocity.x / speed) * ship.maxSpeed;
        ship.velocity.y = (ship.velocity.y / speed) * ship.maxSpeed;
    }

    ship.x += ship.velocity.x;
    ship.y += ship.velocity.y;

    // Screen wrap
    if (ship.x < -ship.radius) ship.x = width + ship.radius;
    if (ship.x > width + ship.radius) ship.x = -ship.radius;
    if (ship.y < -ship.radius) ship.y = height + ship.radius;
    if (ship.y > height + ship.radius) ship.y = -ship.radius;

    // Draw Ship
    if (ship.invulnerable) {
        ship.invulnerableTime--;
        if (ship.invulnerableTime <= 0) ship.invulnerable = false;
    }

    if (!ship.invulnerable || Math.floor(Date.now() / 100) % 2 === 0) {
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        ctx.beginPath();
        ctx.moveTo(ship.radius, 0); // Nose
        ctx.lineTo(-ship.radius, ship.radius * 0.7);
        ctx.lineTo(-ship.radius * 0.5, 0); // Engine indent
        ctx.lineTo(-ship.radius, -ship.radius * 0.7);
        ctx.closePath();
        ctx.strokeStyle = ship.color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = ship.color;
        ctx.stroke();
        
        // Cockpit
        ctx.fillStyle = '#000';
        ctx.fill();
        ctx.restore();
    }

    // --- UPDATE BULLETS ---
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.dx;
        b.y += b.dy;
        b.life--;

        // Draw Bullet
        ctx.beginPath();
        ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#ff00ff';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#ff00ff';
        ctx.fill();

        if (b.life <= 0 || b.x < 0 || b.x > width || b.y < 0 || b.y > height) {
            bullets.splice(i, 1);
        }
    }

    // --- UPDATE ASTEROIDS ---
    // Spawn logic
    if (Math.random() < 0.015 + (score / 50000)) { // Increase spawn rate slowly
        createAsteroid(undefined, undefined, 'large');
    }

    for (let i = asteroids.length - 1; i >= 0; i--) {
        const a = asteroids[i];
        a.x += a.dx;
        a.y += a.dy;
        a.rotation += a.rotationSpeed;

        // Wrap asteroids
        if (a.x < -a.radius * 2) a.x = width + a.radius * 2;
        if (a.x > width + a.radius * 2) a.x = -a.radius * 2;
        if (a.y < -a.radius * 2) a.y = height + a.radius * 2;
        if (a.y > height + a.radius * 2) a.y = -a.radius * 2;

        // Check Collision with Ship
        if (!ship.invulnerable) {
            const dx = ship.x - a.x;
            const dy = ship.y - a.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < ship.radius + a.radius) {
                // Collision!
                ship.health -= 35;
                updateHealthUI();
                createParticles(ship.x, ship.y, '#ff3366', 20);
                ship.invulnerable = true;
                ship.invulnerableTime = 120;
                
                // Destroy asteroid
                asteroids.splice(i, 1);
                
                if (ship.health <= 0) {
                    createParticles(ship.x, ship.y, '#00ffcc', 50); // Ship explosion
                    gameOver();
                    return;
                }
                continue;
            }
        }

        // Check Collision with Bullets
        let asteroidDestroyed = false;
        for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < a.radius) {
                // Hit!
                bullets.splice(j, 1);
                asteroidDestroyed = true;
                
                // Effects
                createParticles(a.x, a.y, '#aaaaaa', 5);
                
                // Logic
                score += (a.size === 'large' ? 100 : a.size === 'medium' ? 250 : 500);
                scoreEl.innerText = "SCORE: " + score;

                // Split
                if (a.size === 'large') {
                    createAsteroid(a.x, a.y, 'medium');
                    createAsteroid(a.x, a.y, 'medium');
                } else if (a.size === 'medium') {
                    createAsteroid(a.x, a.y, 'small');
                    createAsteroid(a.x, a.y, 'small');
                }
                
                break; // Break bullet loop
            }
        }

        if (asteroidDestroyed) {
            asteroids.splice(i, 1);
            continue;
        }

        // Draw Asteroid
        ctx.save();
        ctx.translate(a.x, a.y);
        ctx.rotate(a.rotation);
        ctx.beginPath();
        if (a.vertices.length > 0) {
            ctx.moveTo(a.vertices[0].x, a.vertices[0].y);
            for(let k=1; k<a.vertices.length; k++) {
                ctx.lineTo(a.vertices[k].x, a.vertices[k].y);
            }
        }
        ctx.closePath();
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
        ctx.stroke();
        ctx.restore();
    }

    // --- UPDATE PARTICLES ---
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.dx;
        p.y += p.dy;
        p.life--;
        p.dx *= 0.95; // drag
        p.dy *= 0.95;

        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.globalAlpha = 1.0;

        if (p.life <= 0) particles.splice(i, 1);
    }

    frameCount++;
    requestAnimationFrame(gameLoop);
}

// Button Listeners
startBtn.addEventListener('click', startGame);
restartBtn.addEventListener('click', startGame);

</script>
</body>
</html>